#!/usr/bin/env python
#
# IP: HILICS
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import time
from random import random

from sims.SimIO import SimIO
from sims.AcceleratingActuatorSim import AcceleratingActuatorSim
from sims.MicroLogixComm import MicroLogixComm


##### IO List #####
##
## Analog Inputs (2 max)
##		Temperature
##		Humidity
##
## Analog Outputs (4 max)
## 		Damper - Controls temperature
##		Pump(?) - Controls humidity
## 		
## Digital Inputs (10 max)
##		Door open/closed
##		Locked/Unlocked
##		Lights on/off
## 		Motion (for alarm and/or unlocking door from inside - fire code)
##		Fire
##		Additional overheat sensor??
##		
## Digital outputs (6 max)
##		Lights
##		Door unlock
##		Intrusion alarm
##		Fire alarm
##		Fire supression (gas?)
## 		
##
## NOTE: Additional "network" sensors can be provided - the RPI can send the value to the PLC via Ethernet
##
##


### Class for calculating the current temperature and heat dissapated
### by a temperature zone
###
class Zone:

	def __init__(self, ac_btu, wall_area_ft2, cubic_feet):
		# Start around 23°C
		self.temp_c = 20.0 + (random() * 6.0)
		self.temp_f = (self.temp_c * 9.0 / 5.0) + 32.0

		self.wall_area_ft2 = wall_area_ft2

		# 1 m^2 = 10.7639 ft^2
		#self.wall_area_m2  = wall_area_ft2 / 10.7639

		# 1 m^3 = 35.315 ft^3
		self.volume_m3 = cubic_feet / 35.315
		
		# Density of air (kg/m3) * volume (m3)
		self.mass_kg = 1.2466 * self.volume_m3

		# W = J/s
		self.ac_watts = ac_btu * 0.293


	###
	###	ac_percent = 0 to 100
	###
	###
	def update(self, delta_t_s, ac_percent, outside_temp_f, extra_in_btu=0.0):
		# http://www.sensiblehouse.org/nrg_heatloss.htm
		#	Simplified heat loss
		#		BTU/hr = Area * U (insulation const) * delta_temp
		#
		
		#
		# Power:
		# 		1 BTU/hr is equal to 0.293 watts
		# Energy:
		#		1 Watt = 1 Joule/s
		# 
		# Heat:
		# 		Energy (Joules) = specific heat capacity of substance x mass of substance x temperature difference
		#		Approximate values:
		#			Specific heat capacity of air is 1012 J/kgC
		#			density of air is 1.2466 kg/m3
		#			mass (kg) = density (kg/m3) x volume (m3)
		#
		#			
		#

		# Energy: from Environment (19353.475935951843W), extra (0.0W), ac_out (81676.68W)
		# Energy: from Environment (-90.1108668436654W), extra (7725.805247999997W), ac_out (8790.0W)

		# Heat loss formula converted to watts
		# Units for this formula are in ft and °F
		# Assume U = 0.2 (lots of windows) - the bigger this number, the more impact the outside temp has
		from_environment_w = 0.293 * self.wall_area_ft2 * 0.2 * (outside_temp_f - self.temp_f)

		# Energy in from outside (may be negative or positive)
		from_environment_j = delta_t_s * from_environment_w
		
		extra_in_w = 0.293 * extra_in_btu
		extra_in_j = delta_t_s * extra_in_w

		# Energy taken out by AC unit
		ac_out_w = self.ac_watts * ac_percent / 100.0
		ac_out_j = delta_t_s * ac_out_w
		
		energy_j = (from_environment_j + extra_in_j) - ac_out_j

		delta_t_c = energy_j / (1012.0 * self.mass_kg)


		# Subtract since we're cooling
		self.temp_c += delta_t_c
		self.temp_f = (self.temp_c * 9.0 / 5.0) + 32.0
	
		print(f'DeltaT_C ({delta_t_c}), Temp ({self.temp_f}°F), Total ({energy_j}J), From Environment ({from_environment_w}W), extra ({extra_in_w}W), ac_out ({ac_out_w}W)')


### Class for calculating the status and amount of heat generated by each server
###
class Server:

	def __init__(self):
		
		# The status will determine the percentage of heat
		# generated by the server
		self.RUNNING = 1.0
		self.THROTTLED = 0.75
		self.SHUTDOWN = 0.0
		
		# Estimate based on:
		# https://www.enviromon.net/advanced-server-btu-calculator/
		self.btu_p_hr = 1883.424

		self.status = self.RUNNING
		self.thresh = 90.0 + random() * 20.0
	

	def update(self, temp):
		if temp < self.thresh:
			self.status = self.RUNNING
		elif temp < self.thresh + 10:
			self.status = self.THROTTLED
		else:
			self.status = self.SHUTDOWN


	def get_btu_p_hr(self):
		return self.status * self.btu_p_hr
	




class ServerSim:


	# pin_map[channel] = gpio_index

	#def __init__(self, addr, is_output, pin_map):
	def __init__(self):
		
		# update values  10x per second
		self.mlupdateperiod = 0.1

		self.mlcomm = MicroLogixComm()
		self.mlcomm.connect()
		self.mlcomm.test_connection()

		self.BLDG_EXTRA_BTU = 50000
		self.building_ac_percent = 100.0

		self.server_rm_ac_percent = 100.0

		self.num_servers = 14
		self.servers = []

		for i in range(self.num_servers):
			self.servers.append(Server())


		# Estimated BTU/hr based on https://www.calculator.net/btu-calculator.html
		# Then reduced to get a reasonable minimum temperature
		#
		# Assume a square 100' by 100' building with 10' ceiling
		# volume - 100,000 cubic ft
		# wall surface area = 24000 sq ft  (4 walls + ceiling + floor)

		self.building = Zone(237000.0, 24000.0, 100000.0)

		# BTU estimate based on:
		# https://www.enviromon.net/advanced-server-btu-calculator/
		self.server_room = Zone(29000.0, 600.0, 1000.0)

		self.simio = SimIO()
		self.last_update = 0
		self.time_scale = 1.0
		
		# I:0/0
		self.z0_damper = AcceleratingActuatorSim(100.0, 50.0, 50.0)

		# I:0/1
		self.z0_reheat = AcceleratingActuatorSim(10.0, 2.0, 1.0)
		
		# I:0/0
		self.z0_temp = 0.0
		# I:0/1
		self.z0_humidity = 0.0

		# O:0/0
		self.relay_out_0 = 0
		# O:0/1
		self.relay_out_1 = 0
		# O:0/2
		self.relay_out_2 = 0
		# O:0/3
		self.relay_out_3 = 0
		# O:0/4
		self.relay_out_4 = 0
		# O:0/5
		self.relay_out_5 = 0
		
		
		# I:0/0
		self.dig_in_0 = 0
		# I:0/1
		self.dig_in_1 = 0
		# I:0/2
		self.dig_in_2 = 0
		# I:0/3
		self.dig_in_3 = 0
		# I:0/4
		self.dig_in_4 = 0
		# I:0/5
		self.dig_in_5 = 0
		# I:0/6
		self.dig_in_6 = 0
		
		
		# Project Select for Demo:
		# I:0/7 - I:0/9
		self.proj0 = 0
		self.proj1 = 0
		self.proj2 = 1
		
		
		# I:0.4
		self.analog_in_0 = 0.0
		# I:0.5
		self.analog_in_1 = 0.0


		
	
	
	
	def close(self):
		self.simio.close()



	def update_plc_inputs(self):
	
		vals = [0] * 10
		vals[0] = int(self.dig_in_0)
		vals[1] = int(self.dig_in_1)
		vals[2] = int(self.dig_in_2)
		vals[3] = int(self.dig_in_3)
		vals[4] = int(self.dig_in_4)
		vals[5] = int(self.dig_in_5)
		vals[6] = int(self.dig_in_6)
		
		vals[7] = self.proj0
		vals[8] = self.proj1
		vals[9] = self.proj2
		
		self.simio.write_dig_ins(vals)
	
	
		vals = [self.analog_in_0, self.analog_in_1]
		
		self.simio.write_ang_ins(vals)
		
		
		
	def update(self):
	
		##### Init Simulation Timer #####
		
		if self.last_update == 0:
			self.last_update = time.time()
	
	
		##### Read PLC Analog Outputs #####

		analog_vals = self.simio.read_ang_outs()

		# 0 - 100%
		self.z0_damper.setpoint = analog_vals[0] * 10.0
		self.z0_reheat.setpoint = analog_vals[1] * 10.0
	
		##### Read PLC Relay Outputs #####
		
		relay_vals = self.simio.read_relay_outs()
			
		self.relay_out_0 = relay_vals[0]
		self.relay_out_1 = relay_vals[1]
		self.relay_out_2 = relay_vals[2]
		self.relay_out_3 = relay_vals[3]
		self.relay_out_4 = relay_vals[4]
		self.relay_out_5 = relay_vals[5]
		
		
		
		##### Calculate Time Since Last Update (Seconds) #####
		
		t = time.time()
		delta_t = self.time_scale * (t - self.last_update)
		self.last_update = t
		
		
		
		##### Simulation Logic and Calculations #####
		
		# Put code here
		
		# delta_t is the amount of time that has elapsed since the last update (seconds)
		# use this value to determine how much the process has changed.
		print('Building: ', end='')
		self.building.update(delta_t, self.building_ac_percent, 100.0, self.BLDG_EXTRA_BTU)
		

		server_btu_p_hr_total = 0.0

		# Base power generated by previous state
		for s in self.servers:
			server_btu_p_hr_total += s.get_btu_p_hr()

		print('Server Rm: ', end='')
		self.server_room.update(delta_t, self.server_rm_ac_percent, self.building.temp_f, server_btu_p_hr_total)
		
		# Update for next state
		for s in self.servers:
			s.update(self.server_room.temp_f)


		##### Write PLC Inputs #####
		
		self.update_plc_inputs()
	
	
	
	
	
		
		